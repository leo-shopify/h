{"version":3,"sources":["index.js"],"names":["h","deepCopy","to","from","prop","hasOwnProperty","objToStr","Object","prototype","toString","toArray","Array","slice","DEFAULT_TAG","doc","addChildren","element","item","isArray","reduce","appendChild","nodeType","createTextNode","args","call","arguments","tag","apply","createElement","first","attributes","attrKey","attrVal","removeAttribute","setAttribute","make","document"],"mappings":"aAAA,IAAIA,EAAK,WA4DT,SAASC,EAASC,EAAIC,GACpB,IAAK,IAAMC,KAAQD,EACbA,EAAKE,eAAeD,KACI,iBAAfD,EAAKC,IAAoC,MAAdD,EAAKC,IACzCF,EAAGE,GAAQF,EAAGE,OACdH,EAASC,EAAGE,GAAOD,EAAKC,KAExBF,EAAGE,GAAQD,EAAKC,IArDxB,IAAME,EAAWC,OAAOC,UAAUC,SAM5BC,EAAUC,MAAMH,UAAUI,MAyD1BC,EAAc,MAgIpB,OAzHA,SAAcC,GAUZ,SAASC,EAAYC,EAASC,GAC5B,OAAY,MAARA,EAAuBD,EACvBL,MAAMO,QAAQD,GAAgBA,EAAKE,OAAOJ,EAAaC,IAC3DA,EAAQI,YAAYH,EAAKI,SAAWJ,EAAOH,EAAIQ,eAAeL,IACvDD,GAcT,OAAO,WAOL,IAAMO,EAAOb,EAAQc,KAAKC,UAAW,GAK/BC,EAAMD,UAAU,IAAMZ,EAK5B,GAAmB,mBAARa,EACT,OAAOA,EAAIC,MAAM,KAAMJ,GASzB,IAAIP,OAAA,EAGFA,EADEU,EAAIL,UAA6B,IAAjBK,EAAIL,SACZK,EAGAZ,EAAIc,cAAcF,EAAM,IAAMb,GAW1C,IAAMgB,EAAQN,EAAK,GACnB,GAAc,OAAVM,GAC0B,oBAAzBvB,EAASkB,KAAKK,MAAkC,aAAcA,GAAS,CAO1E,IAAMC,EAAaD,EACnBN,EAAK,GAAK,KAKV,IAAK,IAAMQ,KAAWD,EAAY,CAChC,IAAME,EAAUF,EAAWC,GAWX,MAAZA,EACF9B,EAASe,EAASgB,GACE,MAAXA,EACThB,EAAQiB,gBAAgBF,GAExBf,EAAQkB,aAAaH,EAASC,IASpC,OAAOT,EAAKJ,OAAOJ,EAAaC,IAMxBmB,CAAKC,UA3MR","file":"browser/index.min.js.map","sourcesContent":["var h = (function () {\n'use strict';\n\n/**\n * Lightweight DOM element creation based on a subset of the hyperscript API and\n * compatible with JSX.\n * @module\n * @author leo-shopify <leonardo.rojas@shopify.com>\n */\n\n\n/**\n * @type {function}\n */\nconst objToStr = Object.prototype.toString;\n\n\n/**\n * @type {function}\n */\nconst toArray = Array.prototype.slice;\n\n\n/**\n * Minimal Document interface needed by `h`.\n * @type {Object} DocumentLike\n * @prop {function(string)} createElement\n * @prop {function()} createDocumentFragment\n * @prop {function(string)} createTextNode\n */\n\n\n/**\n * Minimal HTMLElement interface needed by `h`.\n * @type {Object} HTMLElementLike\n * @prop {number} [nodeType=1]\n * @prop {function(string, *)} setAttribute\n * @prop {function(string)} removeAttribute\n * @prop {function(HTMLElementLike)} appendChild\n * @prop {object} [attributes]\n * @prop {array} [children]\n * @prop {string} [tagName]\n */\n\n\n/**\n * Minimal DocumentFragment interface needed by `h`.\n * @type {Object} DocumentFragmentLike\n * @prop {number} [nodeType=11]\n * @prop {function(HTMLElementLike)} appendChild\n * @prop {array} [children]\n */\n\n\n/**\n * Recursively copy an object.\n * @param {object} to The destination.\n * @param {object} from The source.\n * @return {undefined} Copies in-place.\n */\nfunction deepCopy(to, from) {\n  for (const prop in from) {\n    if (from.hasOwnProperty(prop)) {\n      if (typeof from[prop] === 'object' && from[prop] != null) {\n        to[prop] = to[prop] || {};\n        deepCopy(to[prop], from[prop]);\n      } else {\n        to[prop] = from[prop];\n      }\n    }\n  }\n}\n\n\n/**\n * @type {string}\n */\nconst DEFAULT_TAG = 'div';\n\n/**\n * Closure to allow faking DOM `Document`.\n * @param {DocumentLike} doc Object implementing the DOM `Document` interface.\n * @return {function} `h` closed over `doc`.\n */\nfunction make(doc) {\n\n  /**\n   * Add the child to the element. Skip `null` and `undefined`. Recurse on\n   * `Array`.  If the item has a `nodeType` key, assume it is an HTMLElement or\n   * DocumentFragment and add it. Otherwise convert it to a `Text` node.\n   * @param {HTMLElementLike} element The parent element.\n   * @param {*} item The object to be appended as a child of element.\n   * @return {HTMLElementLike} The modified parent element.\n   */\n  function addChildren(element, item) {\n    if (item == null) { return element; }\n    if (Array.isArray(item)) { return item.reduce(addChildren, element); }\n    element.appendChild(item.nodeType ? item : doc.createTextNode(item));\n    return element;\n  }\n\n\n  /**\n   * Creates or modifies DOM elements.\n   * @param {string | HTMLElementLike | function} [tag='div'] Either a string\n   * representing the type of the element to create, an existing element to\n   * modify, or a function to delegate the construction. Defaults to `'div'` if\n   * falsy.\n   * @param {object | null} [attributes=null] Optional attributes object.\n   * @param {...*} [children] Optional children.\n   * @return {HTMLElementLike} Resulting DOM element.\n   */\n  return function h(/* ...args */) {\n\n    /**\n     * Convert the `arguments` object to a real array skipping the first\n     * argument.\n     * @type {array}\n     */\n    const args = toArray.call(arguments, 1); // eslint-disable-line prefer-rest-params\n\n    /**\n     * Ensure `tag` is defined.\n     */\n    const tag = arguments[0] || DEFAULT_TAG; // eslint-disable-line prefer-rest-params\n\n    /**\n     * If `tag` is a function delegate and bail early.\n     */\n    if (typeof tag === 'function') {\n      return tag.apply(null, args); // eslint-disable-line prefer-spread\n    }\n\n    /**\n     * Create the element.\n     *\n     * If `tag.nodeType` is 1 assume it is an existing element.\n     * Else coerce to `string` and create a new element.\n     */\n    let element;\n\n    if (tag.nodeType && tag.nodeType === 1) {\n      element = tag;\n    } else {\n      // eslint-disable-next-line no-implicit-coercion, prefer-template\n      element = doc.createElement(tag + '' || DEFAULT_TAG);\n    }\n\n    /**\n     * Add the attributes.\n     *\n     *\n     * A value qualifies as an `attributes` object if it is: `null`, `Map`,\n     * `WeakMap` and plain `Object`.  If the value is `Object` it cannot contain\n     * a `nodeType` key.\n     */\n    const first = args[0];\n    if (first === null ||\n        (objToStr.call(first) === '[object Object]' && !('nodeType' in first))) {\n\n      /**\n       * If the first element from the arguments is an `attributes` value, copy\n       * it and set the original to null which is skipped by the children\n       * processor. This is faster than `Array.shift()`.\n       */\n      const attributes = first;\n      args[0] = null;\n\n      /**\n       * Iterate over the attributes keys.\n       */\n      for (const attrKey in attributes) { // eslint-disable-line guard-for-in\n        const attrVal = attributes[attrKey];\n\n        /**\n         * If the special key `$` is found, use it to populate the element's\n         * properties.\n         *\n         * If the value of the key is `function` set it as a property.\n         *\n         * If the value of the key is `undefined` or `null` remove the attribute\n         * from the element. Otherwise add it.\n         */\n        if (attrKey === '$') {\n          deepCopy(element, attrVal);\n        } else if (attrVal == null) {\n          element.removeAttribute(attrKey);\n        } else {\n          element.setAttribute(attrKey, attrVal);\n        }\n      }\n    }\n\n    /**\n     * The remaining elements of `rest` are the children. Add them to the\n     * element.\n     */\n    return args.reduce(addChildren, element);\n  };\n}\n\n/* eslint-env browser */\n\nvar index = make(document);\n\nreturn index;\n\n}());\n//# sourceMappingURL=index.js.map\n"]}