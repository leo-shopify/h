#+OPTIONS: toc:nil title:nil

* jsx without react
Even if react is not used in a project you can still take advantage of [[https://babeljs.io/docs/plugins/transform-react-jsx/][jsx]]
syntax if you are using [[https://babeljs.io/][babel]].

** Sample
Fist we have to tell babel what function to use to compile jsx:
#+name: h-header
#+begin_src js
  /** @jsx h */
#+end_src

Then we can start using jsx syntax and in this case output to DOM:
#+name: sample-h-src
#+begin_src js
  function Title(attr, str) {
    return <h1>{str.toUpperCase()}</h1>;
  }

  function Author(attr, ...name) {
    return <a href={`mailto:${attr.email}`}>{name}</a>;
  }

  const body = (<header>
                <Title>Santa Maradona</Title>
                <Author email="mano.negra@example.com">Mano <strong>Negra</strong></Author>
                </header>);

  document.body.appendChild(body);
#+end_src

While babel can compile the script as is, a runtime definition of ~h~ is
needed:
#+name: define-h
#+begin_src js
  function h(node, attributes, ...children) {
    if (typeof node === 'function') {
      return node(attributes, ...children);
    }

    let element;

    if (typeof node === 'string') {
      element = document.createElement(node);
    } else if (typeof node.appendChild === 'function') {
      element = node;
    } else {
      throw new TypeError('node must be a String or an object that implements appendChild');
    }

    if (attributes) {
      Object.keys(attributes).forEach(k => k === '$'
                                      ? Object.assign(element, attributes.$)
                                      : element.setAttribute(k, attributes[k]) );
    }

    return children == null ? element : children.reduce(recurse, element);
  }

  function recurse(node, item) {
    let child;
    if (Array.isArray(item)) { child = item.reduce(recurse, document.createDocumentFragment()); }
    else if (item.nodeType) { child = item; }
    else { child = document.createTextNode(item); }
    node.appendChild(child);
    return node;
  }
#+end_src


** Setup
Install [[https://nodejs.org/en/][nodejs]] if you don't have it already.
In this document the versions used are:
- [[https://nodejs.org/en/][nodejs]]: src_sh[:exports results]{node --version} {{{results(=v8.1.2=)}}}
- [[https://www.npmjs.com/][npm]]: src_sh[:exports results]{npm --version} {{{results(=5.0.3=)}}}

In an empty directory:
1. Create an npm package:
   #+begin_src sh
     npm init --yes
   #+end_src

2. Create a directory for the source code:
   #+begin_src sh
     mkdir src
   #+end_src

3. Install babel:
   #+begin_src sh
     npm install --save-dev babel-cli
   #+end_src

4. Add a build script to =package.json=:
   #+NAME: babel-cmd
   #+begin_src sh :exports none
     babel src -d lib
   #+end_src

   #+begin_src json :noweb yes
     "scripts": {
       "build": "<<babel-cmd>>"
     }
   #+end_src
   #+begin_src js :exports none :noweb yes
     /* eslint-env node */
     const fs = require('fs');
     const name = 'package.json';
     const pj = JSON.parse(fs.readFileSync(name, 'utf8'));
     pj.scripts.build = '<<babel-cmd>>';
     pj.eslintConfig = {parserOptions: {ecmaVersion: 6, ecmaFeatures: {jsx: true}}};
     fs.writeFileSync(name, JSON.stringify(pj, null, 2), 'utf8');
   #+end_src

5. Install /React JSX transform/:
   #+begin_src sh
     npm install --save-dev babel-plugin-transform-react-jsx
   #+end_src

6. Create =.babelrc= configuration file:
   #+begin_src json :tangle .babelrc
     {
       "plugins": ["transform-react-jsx"]
     }
   #+end_src
7. Save the sample scripts as =src/sample.js=.
   #+begin_src js :tangle src/sample.js :noweb yes :exports none
     <<h-header>>

     <<define-h>>

     <<sample-h-src>>
   #+end_src
8. Compile the script:
   #+begin_src sh
     npm run build
   #+end_src


** All together
#+name: reader
#+begin_src sh :exports result :results code :wrap "src javascript :exports none"
  cat lib/sample.js
#+end_src

#+name: compiled
#+RESULTS: reader
#+BEGIN_src javascript :exports none
/** @jsx h */

function h(node, attributes, ...children) {
  if (typeof node === 'function') {
    return node(attributes, ...children);
  }

  let element;

  if (typeof node === 'string') {
    element = document.createElement(node);
  } else if (typeof node.appendChild === 'function') {
    element = node;
  } else {
    throw new TypeError('node must be a String or an object that implements appendChild');
  }

  if (attributes) {
    Object.keys(attributes).forEach(k => k === '$' ? Object.assign(element, attributes.$) : element.setAttribute(k, attributes[k]));
  }

  return children == null ? element : children.reduce(recurse, element);
}

function recurse(node, item) {
  let child;
  if (Array.isArray(item)) {
    child = item.reduce(recurse, document.createDocumentFragment());
  } else if (item.nodeType) {
    child = item;
  } else {
    child = document.createTextNode(item);
  }
  node.appendChild(child);
  return node;
}

function Title(attr, str) {
  return h(
    'h1',
    null,
    str.toUpperCase()
  );
}

function Author(attr, ...name) {
  return h(
    'a',
    { href: `mailto:${attr.email}` },
    name
  );
}

const body = h(
  'header',
  null,
  h(
    Title,
    null,
    'Santa Maradona'
  ),
  h(
    Author,
    { email: 'mano.negra@example.com' },
    'Mano ',
    h(
      'strong',
      null,
      'Negra'
    )
  )
);

document.body.appendChild(body);
#+END_src

#+begin_src html :tangle sample.html :noweb yes
  <!doctype html>
  <title>h</title>
  <body>
    <script>
      <<compiled>>
    </script>
  </body>
#+end_src

*** Tested on
| Firefox 54 | ✅ |
| Safari 10  | ✅ |
| Chrome 59  | ✅ |

* An =el= function with better ergonomics

#+name: define-el
#+begin_src js
  function el(node, ...args) {
    let attributes;
    let children;

    if (args.length < 1) { return h(node, null); }
    let a = args.shift();
    let b = args;

    if (a == null) {
      attributes = null;
      children = b;
    } else if (a.nodeType
               || typeof a === 'string'
               || typeof a === 'number'
               || typeof a === 'boolean') {
      attributes = null;
      children = [a, ...b];
    } else if (Array.isArray(a)) {
      attributes = null;
      children = a;
    } else {
      attributes = a;
      children = b;
    }
    return h(node, attributes, ...children);
  }
#+end_src